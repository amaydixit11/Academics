"""
================================================================================
ULTIMATE AI LAB EXAM CHEATSHEET - ALL ALGORITHMS
================================================================================
Complete reference for: 8-Puzzle, N-Queens, Nim Game, TSP, Map Coloring, 
Graph Search, and all optimization techniques.
================================================================================
"""

# ============================================================================
# ESSENTIAL IMPORTS - COPY THIS FIRST
# ============================================================================
import random
import math
import copy
from typing import Tuple, List
from heapq import heappush, heappop
import heapq
from collections import deque

# For visualization (optional)
# import networkx as nx
# import matplotlib.pyplot as plt


# ============================================================================
# 1. 8-PUZZLE PROBLEM
# ============================================================================

# --- CORE FUNCTIONS ---
goal_8p = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
moves_8p = {'UP': (-1, 0), 'DOWN': (1, 0), 'LEFT': (0, -1), 'RIGHT': (0, 1)}

def flatten(state):
    return [num for row in state for num in row]

def is_solvable(state):
    l = [n for n in flatten(state) if n != 0]
    inv = sum(1 for i in range(len(l)) for j in range(i+1, len(l)) if l[i] > l[j])
    return inv % 2 == 0

def manhattan_distance(state):
    dist = 0
    for i in range(3):
        for j in range(3):
            val = state[i][j]
            if val != 0:
                goal_x, goal_y = divmod(val - 1, 3)
                dist += abs(i - goal_x) + abs(j - goal_y)
    return dist

def get_blank_pos(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def move_tile(state, direction):
    x, y = get_blank_pos(state)
    dx, dy = moves_8p[direction]
    nx, ny = x + dx, y + dy
    if 0 <= nx < 3 and 0 <= ny < 3:
        new_state = [row[:] for row in state]
        new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
        return new_state
    return None

def a_star_8puzzle(start):
    pq = []
    heappush(pq, (manhattan_distance(start), 0, start, []))
    visited = set()
    
    while pq:
        f, g, state, path = heappop(pq)
        state_tuple = tuple(flatten(state))
        
        if state == goal_8p:
            return path
        
        if state_tuple in visited:
            continue
        visited.add(state_tuple)
        
        for move in moves_8p:
            new_state = move_tile(state, move)
            if new_state:
                new_path = path + [move]
                g_new = g + 1
                f_new = g_new + manhattan_distance(new_state)
                heappush(pq, (f_new, g_new, new_state, new_path))
    
    return None


# ============================================================================
# 2. MAP COLORING PROBLEM (CSP)
# ============================================================================

# --- INDIA MAP EXAMPLE ---
states_india = [
    "AP", "AR", "AS", "BR", "CG", "GA", "GJ", "HR", "HP", "JH", "KA", "KL",
    "MP", "MH", "MN", "ML", "MZ", "NL", "OD", "PB", "RJ", "SK", "TN", "TS",
    "TR", "UP", "UK", "WB", "JK"
]

adjacency_india = {
    "AP": ["TS", "OD", "TN", "KA"],
    "AR": ["AS", "NL"],
    "AS": ["AR", "NL", "ML", "TR", "MZ", "MN", "WB"],
    "BR": ["UP", "JH", "WB"],
    "CG": ["UP", "JH", "OD", "MH"],
    "GA": ["MH", "KA"],
    "GJ": ["MH", "RJ"],
    "HR": ["PB", "HP", "UK", "RJ"],
    "HP": ["JK", "PB", "HR", "UK"],
    "JH": ["BR", "UP", "CG", "OD", "WB"],
    "KA": ["MH", "AP", "TS", "TN", "KL", "GA"],
    "KL": ["KA", "TN"],
    "MP": ["RJ", "UP", "CG", "MH", "GJ"],
    "MH": ["GJ", "MP", "CG", "TS", "KA", "GA"],
    "MN": ["AS", "MZ", "NL"],
    "ML": ["AS", "TR"],
    "MZ": ["AS", "MN", "TR"],
    "NL": ["AR", "AS", "MN"],
    "OD": ["WB", "JH", "CG", "AP", "TS"],
    "PB": ["JK", "HP", "HR", "RJ"],
    "RJ": ["PB", "HR", "MP", "GJ", "UP"],
    "SK": ["WB"],
    "TN": ["AP", "KA", "KL"],
    "TS": ["MH", "KA", "AP", "OD"],
    "TR": ["AS", "ML", "MZ"],
    "UP": ["UK", "HR", "RJ", "MP", "CG", "JH", "BR"],
    "UK": ["HP", "HR", "UP"],
    "WB": ["BR", "JH", "OD", "AS", "SK"],
    "JK": ["PB", "HP"]
}

colors_map = ["Red", "Green", "Blue", "Yellow"]

# --- CONSTRAINT CHECKING ---
def is_valid_coloring(state, color, assignment, adjacency):
    """Check if assigning color to state is valid"""
    for neighbor in adjacency.get(state, []):
        if neighbor in assignment and assignment[neighbor] == color:
            return False
    return True

# --- 1. PLAIN BACKTRACKING ---
def backtracking_map(assignment, states, colors, adjacency, steps):
    if len(assignment) == len(states):
        return assignment, steps
    
    var = [s for s in states if s not in assignment][0]
    for color in colors:
        steps[0] += 1
        if is_valid_coloring(var, color, assignment, adjacency):
            assignment[var] = color
            result, steps = backtracking_map(assignment, states, colors, adjacency, steps)
            if result is not None:
                return result, steps
            del assignment[var]
    return None, steps

# --- 2. MRV + LCV HEURISTICS ---
def mrv(assignment, domains, states):
    """Minimum Remaining Values - choose variable with smallest domain"""
    unassigned = [v for v in states if v not in assignment]
    return min(unassigned, key=lambda var: len(domains[var]))

def lcv(var, assignment, domains, adjacency):
    """Least Constraining Value - order colors by impact on neighbors"""
    counts = {}
    for color in domains[var]:
        count = 0
        for neighbor in adjacency.get(var, []):
            if neighbor not in assignment and color in domains[neighbor]:
                count += 1
        counts[color] = count
    return sorted(domains[var], key=lambda c: counts[c])

def backtracking_mrv_lcv(assignment, domains, states, adjacency, steps):
    if len(assignment) == len(states):
        return assignment, steps
    
    var = mrv(assignment, domains, states)
    for color in lcv(var, assignment, domains, adjacency):
        steps[0] += 1
        if is_valid_coloring(var, color, assignment, adjacency):
            assignment[var] = color
            saved_domains = copy.deepcopy(domains)
            
            # Forward checking - remove color from neighbors' domains
            for neighbor in adjacency.get(var, []):
                if color in domains[neighbor]:
                    domains[neighbor].remove(color)
            
            result, steps = backtracking_mrv_lcv(assignment, domains, states, adjacency, steps)
            if result is not None:
                return result, steps
            
            assignment.pop(var)
            domains = saved_domains
    return None, steps

# --- 3. AC-3 ALGORITHM ---
def ac3(domains, adjacency):
    """Arc Consistency Algorithm - prune inconsistent values"""
    queue = deque([(xi, xj) for xi in domains for xj in adjacency.get(xi, [])])
    
    while queue:
        xi, xj = queue.popleft()
        if revise(domains, xi, xj):
            if not domains[xi]:
                return False  # Domain wipeout - no solution
            for xk in adjacency.get(xi, []):
                if xk != xj:
                    queue.append((xk, xi))
    return True

def revise(domains, xi, xj):
    """Remove values from xi's domain that conflict with all values in xj"""
    revised = False
    for x in domains[xi][:]:
        # If all values in xj conflict with x, remove x
        if all(x == y for y in domains[xj]):
            domains[xi].remove(x)
            revised = True
    return revised

def backtracking_ac3(assignment, domains, states, adjacency, steps):
    """Backtracking with AC-3 constraint propagation"""
    if len(assignment) == len(states):
        return assignment, steps
    
    var = mrv(assignment, domains, states)
    for color in lcv(var, assignment, domains, adjacency):
        steps[0] += 1
        if is_valid_coloring(var, color, assignment, adjacency):
            assignment[var] = color
            saved_domains = copy.deepcopy(domains)
            
            # Remove color from neighbors' domains
            for neighbor in adjacency.get(var, []):
                if color in domains[neighbor]:
                    domains[neighbor].remove(color)
            
            # Apply AC-3 for early failure detection
            if ac3(domains, adjacency):
                result, steps = backtracking_ac3(assignment, domains, states, adjacency, steps)
                if result is not None:
                    return result, steps
            
            assignment.pop(var)
            domains = saved_domains
    return None, steps

# --- USAGE EXAMPLE ---
def solve_map_coloring():
    """Solve India map coloring with all three methods"""
    results = []
    
    # 1. Plain Backtracking
    print("Plain Backtracking:")
    sol1, steps1 = backtracking_map({}, states_india, colors_map, adjacency_india, [0])
    print(f"Steps: {steps1[0]}")
    results.append(("Plain", steps1[0]))
    
    # 2. MRV + LCV
    print("\nMRV + LCV:")
    domains2 = {s: colors_map[:] for s in states_india}
    sol2, steps2 = backtracking_mrv_lcv({}, domains2, states_india, adjacency_india, [0])
    print(f"Steps: {steps2[0]}")
    results.append(("MRV+LCV", steps2[0]))
    
    # 3. MRV + LCV + AC-3
    print("\nMRV + LCV + AC-3:")
    domains3 = {s: colors_map[:] for s in states_india}
    sol3, steps3 = backtracking_ac3({}, domains3, states_india, adjacency_india, [0])
    print(f"Steps: {steps3[0]}")
    results.append(("AC-3", steps3[0]))
    
    print("\n--- Comparison ---")
    for name, steps in results:
        print(f"{name}: {steps} steps")
    
    return sol3


# ============================================================================
# 3. N-QUEENS PROBLEM
# ============================================================================

N = 8  # Board size

def count_conflicts(board):
    """Count attacking queen pairs"""
    conflicts = 0
    for i in range(len(board)):
        for j in range(i + 1, len(board)):
            if board[i] == board[j] or abs(board[i] - board[j]) == abs(i - j):
                conflicts += 1
    return conflicts

def min_conflict_step(board):
    """Move one queen to minimize conflicts"""
    col = random.randint(0, len(board) - 1)
    best_row = board[col]
    best_conflict = count_conflicts(board)
    
    for row in range(len(board)):
        if row == board[col]:
            continue
        new_board = board[:]
        new_board[col] = row
        current_conflict = count_conflicts(new_board)
        if current_conflict < best_conflict:
            best_conflict = current_conflict
            best_row = row
    
    board[col] = best_row
    return board, best_conflict

def solve_nqueens(n=8, max_steps=500):
    """Local search with random restart"""
    attempts = 0
    while True:
        attempts += 1
        board = [random.randint(0, n - 1) for _ in range(n)]
        conflicts = count_conflicts(board)
        
        steps = 0
        while steps < max_steps:
            if conflicts == 0:
                return board, attempts, steps
            
            board, new_conflicts = min_conflict_step(board)
            if new_conflicts == conflicts:
                break  # Local minimum
            
            conflicts = new_conflicts
            steps += 1

# --- SIMULATED ANNEALING ---
def get_neighbor_nqueens(board):
    """Generate neighbor state"""
    n = len(board)
    if random.random() < 0.2:  # Swap
        i, j = random.sample(range(n), 2)
        new_board = board[:]
        new_board[i], new_board[j] = new_board[j], new_board[i]
        return new_board
    # Move one queen
    i = random.randrange(n)
    r = random.randrange(n)
    while r == board[i]:
        r = random.randrange(n)
    new_board = board[:]
    new_board[i] = r
    return new_board

def simulated_annealing_nqueens(n=8):
    """Simulated Annealing for N-Queens"""
    board = [random.randint(0, n - 1) for _ in range(n)]
    cost = count_conflicts(board)
    best_board, best_cost = board[:], cost
    
    T = 10.0
    T_min = 1e-4
    alpha = 0.995
    it = 0
    max_it = 200000
    
    while T > T_min and cost > 0 and it < max_it:
        it += 1
        new_board = get_neighbor_nqueens(board)
        new_cost = count_conflicts(new_board)
        
        if new_cost < cost or random.random() < math.exp((cost - new_cost) / T):
            board, cost = new_board, new_cost
            if cost < best_cost:
                best_board, best_cost = board[:], cost
        
        T *= alpha
    
    return best_board, best_cost, it

def print_board(board):
    """Visualize board"""
    n = len(board)
    for row in range(n):
        print(' '.join('Q' if board[col] == row else '.' for col in range(n)))


# ============================================================================
# 4. NIM GAME (MINIMAX & ALPHA-BETA)
# ============================================================================

def is_terminal_nim(state):
    return all(h == 0 for h in state)

def get_moves_nim(state):
    moves = []
    for i, heap in enumerate(state):
        if heap > 0:
            for remove in range(1, heap + 1):
                new_state = list(state)
                new_state[i] -= remove
                moves.append(tuple(new_state))
    return moves

# --- MINIMAX ---
def minimax(state, maximizing=True):
    if is_terminal_nim(state):
        return -1 if maximizing else 1
    
    if maximizing:
        value = float('-inf')
        for move in get_moves_nim(state):
            value = max(value, minimax(move, False))
        return value
    else:
        value = float('inf')
        for move in get_moves_nim(state):
            value = min(value, minimax(move, True))
        return value

def find_best_move_minimax(state):
    best_val = float('-inf')
    best_move = None
    for succ in get_moves_nim(state):
        val = minimax(succ, False)
        if val > best_val:
            best_val = val
            best_move = succ
    return best_move, best_val

# --- ALPHA-BETA PRUNING ---
stats = {"visited": 0, "cutoffs": 0}

def alpha_beta(state, is_max, alpha, beta):
    stats["visited"] += 1
    
    if is_terminal_nim(state):
        return -1 if is_max else 1
    
    if is_max:
        best_val = float('-inf')
        for child in get_moves_nim(state):
            score = alpha_beta(child, False, alpha, beta)
            best_val = max(best_val, score)
            alpha = max(alpha, best_val)
            if alpha >= beta:
                stats["cutoffs"] += 1
                break
        return best_val
    else:
        best_val = float('inf')
        for child in get_moves_nim(state):
            score = alpha_beta(child, True, alpha, beta)
            best_val = min(best_val, score)
            beta = min(beta, best_val)
            if alpha >= beta:
                stats["cutoffs"] += 1
                break
        return best_val

def find_best_move_alphabeta(state):
    best_val = float('-inf')
    best_move = None
    alpha = float('-inf')
    beta = float('inf')
    
    for succ in get_moves_nim(state):
        val = alpha_beta(succ, False, alpha, beta)
        if val > best_val:
            best_val = val
            best_move = succ
        alpha = max(alpha, best_val)
    
    return best_move, best_val


# ============================================================================
# 5. HAMILTONIAN CYCLE / TSP
# ============================================================================

def prims_mst(graph, nodes):
    """MST heuristic for TSP"""
    if not nodes:
        return 0
    start = next(iter(nodes))
    visited = {start}
    min_edges = [(w, start, nb) for nb, w in graph[start] if nb in nodes]
    heapq.heapify(min_edges)
    cost = 0
    
    while min_edges and len(visited) < len(nodes):
        w, u, v = heapq.heappop(min_edges)
        if v in visited:
            continue
        visited.add(v)
        cost += w
        for nb, wt in graph[v]:
            if nb in nodes and nb not in visited:
                heapq.heappush(min_edges, (wt, v, nb))
    
    return cost if len(visited) == len(nodes) else math.inf

def tsp_astar(graph, start_node):
    """A* for TSP with MST heuristic"""
    all_nodes = list(graph.keys())
    node_index = {v: i for i, v in enumerate(all_nodes)}
    n = len(all_nodes)
    
    def mask(v):
        return 1 << node_index[v]
    
    all_mask = (1 << n) - 1
    start_mask = mask(start_node)
    
    frontier = [(0, 0, start_node, start_mask, [start_node])]
    best_cost = {}
    
    while frontier:
        f, g, u, state, path = heapq.heappop(frontier)
        
        if state == all_mask:
            for nb, w in graph[u]:
                if nb == start_node:
                    return path + [start_node]
            continue
        
        if (u, state) in best_cost and best_cost[(u, state)] <= g:
            continue
        best_cost[(u, state)] = g
        
        for nb, w in graph[u]:
            if state & mask(nb):
                continue
            new_state = state | mask(nb)
            new_g = g + w
            remaining = {v for v in all_nodes if not (new_state & mask(v))}
            heuristic = prims_mst(graph, remaining | {start_node, nb})
            heapq.heappush(frontier, (new_g + heuristic, new_g, nb, new_state, path + [nb]))
    
    return None

# --- BRANCH & BOUND TSP ---
def tsp_branch_bound(graph, start):
    """Branch & Bound for TSP"""
    n = len(graph)
    best = {"cost": math.inf, "path": []}
    min_edge = [min(w for _, w in graph[v]) for v in range(n)]
    
    def dfs(path, visited, curr_cost):
        u = path[-1]
        est = curr_cost + sum(min_edge[v] for v in range(n) if v not in visited)
        if est >= best["cost"]:
            return
        
        if len(path) == n:
            for nb, w in graph[u]:
                if nb == start:
                    total = curr_cost + w
                    if total < best["cost"]:
                        best["cost"] = total
                        best["path"] = path + [start]
            return
        
        for nb, w in graph[u]:
            if nb not in visited:
                dfs(path + [nb], visited | {nb}, curr_cost + w)
    
    dfs([start], {start}, 0)
    return (best["path"], best["cost"]) if best["cost"] < math.inf else (None, math.inf)


# ============================================================================
# 6. GRAPH SEARCH ALGORITHMS
# ============================================================================

# --- BFS ---
def bfs(graph, start, goal):
    queue = deque([(start, [start])])
    visited = {start}
    
    while queue:
        node, path = queue.popleft()
        if node == goal:
            return path
        
        for neighbor, _ in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    return None

# --- DFS ---
def dfs(graph, start, goal):
    stack = [(start, [start])]
    visited = set()
    
    while stack:
        node, path = stack.pop()
        if node in visited:
            continue
        visited.add(node)
        
        if node == goal:
            return path
        
        for neighbor, _ in graph.get(node, []):
            if neighbor not in visited:
                stack.append((neighbor, path + [neighbor]))
    return None

# --- UCS (Dijkstra) ---
def ucs(graph, start, goal):
    pq = [(0, start, [start])]
    visited = set()
    
    while pq:
        cost, node, path = heappop(pq)
        if node in visited:
            continue
        visited.add(node)
        
        if node == goal:
            return path, cost
        
        for neighbor, edge_cost in graph.get(node, []):
            if neighbor not in visited:
                heappush(pq, (cost + edge_cost, neighbor, path + [neighbor]))
    return None, float('inf')

# --- A* ---
def astar(graph, start, goal, heuristic):
    pq = [(heuristic(start, goal), 0, start, [start])]
    visited = {}
    
    while pq:
        f, g, node, path = heappop(pq)
        if node in visited and visited[node] <= g:
            continue
        visited[node] = g
        
        if node == goal:
            return path, g
        
        for neighbor, cost in graph.get(node, []):
            new_g = g + cost
            h = heuristic(neighbor, goal)
            heappush(pq, (new_g + h, new_g, neighbor, path + [neighbor]))
    return None, float('inf')


# ============================================================================
# 7. UTILITY FUNCTIONS
# ============================================================================

def create_graph(edges):
    """Create adjacency list from edges [(u, v, w), ...]"""
    graph = {}
    for u, v, w in edges:
        if u not in graph:
            graph[u] = []
        if v not in graph:
            graph[v] = []
        graph[u].append((v, w))
        graph[v].append((u, w))  # For undirected
    return graph

def euclidean_dist(p1, p2):
    return math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)

def manhattan_dist(p1, p2):
    return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])


# ============================================================================
# 8. QUICK REFERENCE TEMPLATES
# ============================================================================

"""
=== TEMPLATE 1: Basic Backtracking ===
def backtrack(state, path):
    if is_goal(state):
        return path
    for next_state in get_successors(state):
        if is_valid(next_state):
            result = backtrack(next_state, path + [next_state])
            if result:
                return result
    return None

=== TEMPLATE 2: A* Search ===
def astar_template(start):
    pq = [(h(start), 0, start, [])]
    visited = set()
    while pq:
        f, g, state, path = heappop(pq)
        if state == goal:
            return path
        if state in visited:
            continue
        visited.add(state)
        for succ in successors(state):
            heappush(pq, (g+1+h(succ), g+1, succ, path+[succ]))
    return None

=== TEMPLATE 3: Minimax with Alpha-Beta ===
def minimax_ab(state, is_max, alpha, beta):
    if is_terminal(state):
        return evaluate(state)
    if is_max:
        v = -inf
        for move in moves(state):
            v = max(v, minimax_ab(move, False, alpha, beta))
            alpha = max(alpha, v)
            if alpha >= beta:
                break
        return v
    else:
        v = inf
        for move in moves(state):
            v = min(v, minimax_ab(move, True, alpha, beta))
            beta = min(beta, v)
            if alpha >= beta:
                break
        return v

=== TEMPLATE 4: Simulated Annealing ===
def simulated_annealing(start):
    state = start
    cost = evaluate(state)
    T = 10.0
    while T > 0.0001:
        neighbor = get_neighbor(state)
        new_cost = evaluate(neighbor)
        if new_cost < cost or random.random() < exp((cost-new_cost)/T):
            state, cost = neighbor, new_cost
        T *= 0.995
    return state

=== TEMPLATE 5: CSP with MRV + LCV ===
def csp_solve(assignment, domains):
    if len(assignment) == len(variables):
        return assignment
    var = min([v for v in variables if v not in assignment], 
              key=lambda x: len(domains[x]))  # MRV
    
    # LCV ordering
    values = sorted(domains[var], 
                   key=lambda c: count_constraints(var, c))
    
    for val in values:
        if is_consistent(var, val, assignment):
            assignment[var] = val
            result = csp_solve(assignment, domains)
            if result:
                return result
            del assignment[var]
    return None
"""


# ============================================================================
# 9. KEY FORMULAS & CONCEPTS
# ============================================================================

"""
=== HEURISTICS ===
Manhattan Distance: |x1-x2| + |y1-y2|
Euclidean Distance: sqrt((x1-x2)¬≤ + (y1-y2)¬≤)
Misplaced Tiles: count of tiles not in goal position

=== SEARCH ALGORITHMS ===
BFS: Shortest path (unweighted), O(V+E) space
DFS: Memory efficient, may not find shortest
UCS: Optimal for weighted graphs, like Dijkstra
A*: f(n) = g(n) + h(n), optimal if h is admissible

=== GAME THEORY ===
Minimax: V(s) = max/min of child values
Alpha-Beta: Prunes branches where Œ± ‚â• Œ≤
Œ±: best value for MAX found so far
Œ≤: best value for MIN found so far

=== CSP TECHNIQUES ===
MRV: Choose variable with minimum remaining values
LCV: Try value that rules out fewest choices for neighbors
AC-3: Enforce arc consistency, prune domains early
Forward Checking: Remove inconsistent values after assignment

=== OPTIMIZATION ===
Simulated Annealing: Accept worse with P = e^(ŒîE/T)
Branch & Bound: Prune if lower_bound ‚â• best_known
Local Search: Iterative improvement, may get stuck

=== COMPLEXITY ===
8-Puzzle: State space = 9!/2 = 181,440
N-Queens: O(N!) backtracking, O(N¬≤) conflicts check
Minimax: O(b^d), Alpha-Beta: O(b^(d/2)) best case
TSP: O(n!) brute force, O(n¬≤2^n) DP
"""


# ============================================================================
# 10. EXAM STRATEGY & DEBUGGING
# ============================================================================

"""
=== TIME MANAGEMENT (25 min problem) ===
1. Read carefully (2 min)
2. Identify algorithm type (1 min)
3. Write skeleton (3 min)
4. Implement core logic (12 min)
5. Test with example (4 min)
6. Debug/optimize (3 min)

=== ALGORITHM SELECTION ===
Problem Type ‚Üí Algorithm
- Shortest path, weighted ‚Üí A* or UCS
- Shortest path, unweighted ‚Üí BFS
- Any path quickly ‚Üí DFS
- Optimal solution required ‚Üí Branch & Bound or A*
- Large state space ‚Üí Local Search / Simulated Annealing
- Two-player game ‚Üí Minimax with Alpha-Beta
- Constraint satisfaction ‚Üí Backtracking + CSP techniques
- Map coloring ‚Üí CSP with AC-3
- Scheduling/assignment ‚Üí CSP or Local Search
- Puzzle solving ‚Üí A* with admissible heuristic

=== COMMON MISTAKES TO AVOID ===
1. Not checking if state already visited
2. Forgetting to convert state to tuple for hashing
3. Wrong priority in heap (f = g + h for A*)
4. Not handling terminal states in minimax
5. Forgetting to update alpha/beta bounds
6. Not deep copying states when modifying
7. Off-by-one errors in indices
8. Domain wipeout not detected in CSP
9. Incorrect constraint checking
10. Missing base cases in recursion

=== DEBUGGING CHECKLIST ===
‚ñ° Print current state at each step
‚ñ° Verify goal condition is correct
‚ñ° Check heuristic is admissible (never overestimates)
‚ñ° Ensure visited set uses tuples
‚ñ° Confirm neighbor generation is correct
‚ñ° Validate constraint checking logic
‚ñ° Test with small/simple input first
‚ñ° Add step counter to track progress
‚ñ° Check for infinite loops
‚ñ° Verify return values match expected format

=== QUICK FIXES ===
Infinite loop ‚Üí Add visited set
Wrong answer ‚Üí Check goal/constraint condition
Too slow ‚Üí Add pruning/better heuristic
Memory error ‚Üí Use DFS instead of BFS
No solution found ‚Üí Check if problem is solvable
Domain error ‚Üí Ensure deep copy of domains
"""


# ============================================================================
# 11. COMPLETE WORKING EXAMPLES
# ============================================================================

def example_8puzzle():
    """Complete 8-Puzzle example"""
    print("="*60)
    print("8-PUZZLE EXAMPLE")
    print("="*60)
    start = [[1, 2, 3], [4, 6, 0], [7, 5, 8]]
    
    print("Initial:")
    for row in start:
        print(row)
    
    if is_solvable(start):
        solution = a_star_8puzzle(start)
        print(f"\nSolution in {len(solution)} moves: {solution}")
    else:
        print("Not solvable!")

def example_map_coloring():
    """Complete Map Coloring example"""
    print("="*60)
    print("MAP COLORING EXAMPLE (India)")
    print("="*60)
    
    # Small example for demo
    states = ["MH", "KA", "GA", "TN", "KL"]
    adjacency = {
        "MH": ["KA", "GA"],
        "KA": ["MH", "TN", "KL", "GA"],
        "GA": ["MH", "KA"],
        "TN": ["KA", "KL"],
        "KL": ["KA", "TN"]
    }
    colors = ["Red", "Green", "Blue"]
    
    print(f"States: {states}")
    print(f"Colors: {colors}")
    
    # Plain Backtracking
    sol, steps = backtracking_map({}, states, colors, adjacency, [0])
    print(f"\nPlain Backtracking: {steps[0]} steps")
    print(f"Solution: {sol}")
    
    # With heuristics
    domains = {s: colors[:] for s in states}
    sol2, steps2 = backtracking_mrv_lcv({}, domains, states, adjacency, [0])
    print(f"\nMRV + LCV: {steps2[0]} steps")
    print(f"Solution: {sol2}")

def example_nqueens():
    """Complete N-Queens example"""
    print("="*60)
    print("N-QUEENS EXAMPLE")
    print("="*60)
    
    # Local Search
    board, attempts, steps = solve_nqueens(8)
    print(f"Local Search: {attempts} restarts, {steps} final steps")
    print("Solution:")
    print_board(board)
    
    # Simulated Annealing
    print("\nSimulated Annealing:")
    board2, cost, iters = simulated_annealing_nqueens(8)
    print(f"Cost: {cost}, Iterations: {iters}")
    if cost == 0:
        print_board(board2)

def example_nim():
    """Complete Nim Game example"""
    print("="*60)
    print("NIM GAME EXAMPLE")
    print("="*60)
    
    initial = (3, 4, 5)
    print(f"Initial: {initial}\n")
    
    # Alpha-Beta
    stats["visited"] = 0
    stats["cutoffs"] = 0
    move, val = find_best_move_alphabeta(initial)
    print(f"Alpha-Beta:")
    print(f"  Best move: {initial} ‚Üí {move}")
    print(f"  Value: {val}")
    print(f"  Nodes: {stats['visited']}, Cutoffs: {stats['cutoffs']}")

def example_tsp():
    """Complete TSP example"""
    print("="*60)
    print("TSP/HAMILTONIAN CYCLE EXAMPLE")
    print("="*60)
    
    graph = {
        'A': [('B', 2), ('C', 9), ('D', 10)],
        'B': [('A', 2), ('C', 6), ('D', 4)],
        'C': [('A', 9), ('B', 6), ('D', 3)],
        'D': [('A', 10), ('B', 4), ('C', 3)]
    }
    
    cycle = tsp_astar(graph, 'A')
    if cycle:
        print(f"Hamiltonian Cycle: {' ‚Üí '.join(cycle)}")


# ============================================================================
# 12. AUSTRALIA MAP COLORING (From PDF)
# ============================================================================

def solve_australia_map():
    """Australia map coloring problem"""
    states_aus = ["WA", "NT", "SA", "Q", "NSW", "V", "T"]
    
    adjacency_aus = {
        "WA": ["NT", "SA"],
        "NT": ["WA", "SA", "Q"],
        "SA": ["WA", "NT", "Q", "NSW", "V"],
        "Q": ["NT", "SA", "NSW"],
        "NSW": ["Q", "SA", "V"],
        "V": ["SA", "NSW"],
        "T": []  # Tasmania - no neighbors
    }
    
    colors = ["Red", "Green", "Blue"]
    
    print("="*60)
    print("AUSTRALIA MAP COLORING")
    print("="*60)
    print(f"States: {states_aus}")
    print(f"Colors: {colors}\n")
    
    # Solve with AC-3
    domains = {s: colors[:] for s in states_aus}
    solution, steps = backtracking_ac3({}, domains, states_aus, adjacency_aus, [0])
    
    print(f"Solution found in {steps[0]} steps:")
    for state in states_aus:
        print(f"  {state}: {solution[state]}")
    
    return solution


# ============================================================================
# 13. ADVANCED CSP TECHNIQUES
# ============================================================================

def forward_checking(var, value, domains, adjacency):
    """Forward checking - prune domains after assignment"""
    pruned = {}
    for neighbor in adjacency.get(var, []):
        if value in domains[neighbor]:
            if neighbor not in pruned:
                pruned[neighbor] = []
            pruned[neighbor].append(value)
            domains[neighbor].remove(value)
    return pruned

def restore_domains(pruned, domains):
    """Restore pruned values"""
    for var, values in pruned.items():
        domains[var].extend(values)

def degree_heuristic(assignment, adjacency, states):
    """Degree heuristic - choose variable with most constraints"""
    unassigned = [v for v in states if v not in assignment]
    return max(unassigned, key=lambda v: len(adjacency.get(v, [])))

def backtracking_forward_checking(assignment, domains, states, adjacency, steps):
    """Backtracking with forward checking"""
    if len(assignment) == len(states):
        return assignment, steps
    
    var = mrv(assignment, domains, states)
    
    for color in lcv(var, assignment, domains, adjacency):
        steps[0] += 1
        if is_valid_coloring(var, color, assignment, adjacency):
            assignment[var] = color
            
            # Forward checking
            pruned = forward_checking(var, color, domains, adjacency)
            
            # Check if any domain is empty
            if all(len(domains[v]) > 0 for v in states if v not in assignment):
                result, steps = backtracking_forward_checking(
                    assignment, domains, states, adjacency, steps
                )
                if result is not None:
                    return result, steps
            
            # Backtrack
            assignment.pop(var)
            restore_domains(pruned, domains)
    
    return None, steps


# ============================================================================
# 14. PERFORMANCE COMPARISON TEMPLATE
# ============================================================================

def compare_algorithms(problem_name, algorithms, *args):
    """Generic performance comparison"""
    import time
    
    print(f"\n{'='*60}")
    print(f"{problem_name.upper()} - ALGORITHM COMPARISON")
    print(f"{'='*60}\n")
    
    results = []
    
    for name, func in algorithms:
        print(f"Running {name}...")
        start_time = time.time()
        result = func(*args)
        elapsed = time.time() - start_time
        
        if isinstance(result, tuple):
            solution, steps = result if len(result) == 2 else (result[0], result[1])
        else:
            solution, steps = result, "N/A"
        
        results.append((name, steps if steps != "N/A" else "-", f"{elapsed:.4f}s"))
        print(f"  Steps: {steps if steps != 'N/A' else '-'}, Time: {elapsed:.4f}s\n")
    
    # Print comparison table
    print(f"{'Algorithm':<30} {'Steps':<15} {'Time'}")
    print("-" * 60)
    for name, steps, time in results:
        print(f"{name:<30} {str(steps):<15} {time}")
    
    return results


# ============================================================================
# 15. EXAM-READY SNIPPETS
# ============================================================================

# Quick solvability check for 8-puzzle
def quick_solvable_check(state):
    flat = [n for row in state for n in row if n != 0]
    inv = sum(1 for i in range(len(flat)) for j in range(i+1, len(flat)) if flat[i] > flat[j])
    return inv % 2 == 0

# Quick conflict count for N-Queens
def quick_conflicts(board):
    c = 0
    n = len(board)
    for i in range(n):
        for j in range(i+1, n):
            if board[i] == board[j] or abs(board[i]-board[j]) == abs(i-j):
                c += 1
    return c

# Quick graph creation
def quick_graph(edges):
    g = {}
    for u, v, w in edges:
        g.setdefault(u, []).append((v, w))
        g.setdefault(v, []).append((u, w))
    return g

# Quick CSP setup
def quick_csp(variables, domain, constraints):
    return {
        'variables': variables,
        'domains': {v: domain[:] for v in variables},
        'constraints': constraints
    }


# ============================================================================
# MAIN - RUN ALL EXAMPLES
# ============================================================================

if __name__ == "__main__":
    print("\n" + "="*70)
    print(" ULTIMATE AI LAB EXAM CHEATSHEET - ALL EXAMPLES")
    print("="*70 + "\n")
    
    # Uncomment to run specific examples:
    
    # example_8puzzle()
    # print("\n" * 2)
    
    # example_map_coloring()
    # print("\n" * 2)
    
    # solve_australia_map()
    # print("\n" * 2)
    
    # example_nqueens()
    # print("\n" * 2)
    
    # example_nim()
    # print("\n" * 2)
    
    # example_tsp()
    
    print("\n" + "="*70)
    print(" ALL ALGORITHMS LOADED - READY FOR EXAM!")
    print("="*70)
    print("\nQUICK ACCESS:")
    print("  ‚Ä¢ 8-Puzzle: a_star_8puzzle(start)")
    print("  ‚Ä¢ Map Coloring: backtracking_ac3()")
    print("  ‚Ä¢ N-Queens: solve_nqueens(8)")
    print("  ‚Ä¢ Nim Game: find_best_move_alphabeta(state)")
    print("  ‚Ä¢ TSP: tsp_astar(graph, start)")
    print("  ‚Ä¢ Graph Search: bfs/dfs/ucs/astar")
    print("\nGOOD LUCK! üöÄ")


# ============================================================================
# EXAM CHEAT CODES - MEMORIZE THESE
# ============================================================================

"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                        EXAM CHEAT CODES                                 ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üéØ PROBLEM IDENTIFICATION (First 30 seconds):
   Keywords ‚Üí Algorithm
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   "shortest path" ‚Üí BFS/A*
   "optimal cost" ‚Üí UCS/A*/Branch & Bound
   "color map/assign" ‚Üí CSP Backtracking
   "place queens" ‚Üí Local Search/SA
   "game/two players" ‚Üí Minimax/Alpha-Beta
   "visit all nodes" ‚Üí TSP/Hamiltonian
   "sliding puzzle" ‚Üí A* with Manhattan

üìù CODE STRUCTURE (Always start with):
   1. Define state representation
   2. Write is_goal() / is_terminal()
   3. Write get_successors() / get_moves()
   4. Write is_valid() / constraint_check()
   5. Implement main algorithm
   6. Add printing/visualization

‚ö° PERFORMANCE BOOSTERS:
   ‚Ä¢ Use tuple(state) for visited sets
   ‚Ä¢ Implement alpha-beta pruning (saves ~50% nodes)
   ‚Ä¢ Add AC-3 to CSP (can reduce steps by 10x)
   ‚Ä¢ Use MRV + LCV (reduces backtracking)
   ‚Ä¢ Memoize expensive calculations

üîß DEBUGGING SHORTCUTS:
   print(f"State: {state}, Valid: {is_valid(state)}")
   print(f"Visited: {len(visited)}, Steps: {steps}")
   print(f"Domain: {domains[var]}")
   print(f"Alpha: {alpha}, Beta: {beta}")

üí° COMMON TRAP QUESTIONS:
   ‚Ä¢ "Is this puzzle solvable?" ‚Üí Check inversions
   ‚Ä¢ "Why did it fail?" ‚Üí Domain wipeout or no valid assignment
   ‚Ä¢ "Which is faster?" ‚Üí Alpha-beta > Minimax, AC-3 > Plain
   ‚Ä¢ "Admissible heuristic?" ‚Üí Never overestimates true cost
   ‚Ä¢ "Complete vs Optimal?" ‚Üí BFS complete+optimal, DFS incomplete

üéì POINT-MAXIMIZATION STRATEGY:
   1. Identify algorithm correctly (25%)
   2. Write correct skeleton (25%)
   3. Implement core logic (30%)
   4. Get basic test case working (15%)
   5. Optimize/explain (5%)

‚è∞ TIME ALLOCATION (25 min total):
   Reading: 2 min
   Planning: 2 min
   Coding: 15 min
   Testing: 4 min
   Cleanup: 2 min

üéØ PARTIAL CREDIT TACTICS:
   ‚Ä¢ Write pseudocode if stuck on implementation
   ‚Ä¢ Add comments explaining your approach
   ‚Ä¢ Show you understand the concept even if code is incomplete
   ‚Ä¢ Test with simple example and show expected output
   ‚Ä¢ Mention complexity/optimizations in comments

Remember: 
- Working code with suboptimal algorithm > Perfect algorithm with bugs
- Simple solution that works > Complex solution that doesn't
- Comment your assumptions and edge cases
- Test with smallest possible input first

GOOD LUCK! üçÄ
"""
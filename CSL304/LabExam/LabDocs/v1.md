"""
================================================================================
AI LAB EXAM COMPREHENSIVE REFERENCE GUIDE
================================================================================
All algorithms, implementations, and problem-solving approaches covered.
Ready to copy-paste for lab exam.
================================================================================

TABLE OF CONTENTS:
1. 8-PUZZLE PROBLEM (A*, DFS Branch & Bound, BFS)
2. HAMILTONIAN CYCLE PROBLEM (Branch & Bound, A*)
3. N-QUEENS PROBLEM (Local Search, Simulated Annealing)
4. NIM GAME (Minimax, Alpha-Beta Pruning)
5. GRAPH SEARCH ALGORITHMS (BFS, DFS, UCS, A*)
6. TRAVELING SALESMAN PROBLEM (TSP)
7. UTILITY FUNCTIONS & COMMON HELPERS

================================================================================
"""

# ============================================================================
# 1. 8-PUZZLE PROBLEM
# ============================================================================

"""
PROBLEM: Sliding puzzle with 8 numbered tiles and 1 blank space on 3x3 grid.
GOAL: Arrange tiles from initial state to goal state.
MOVES: Move blank UP, DOWN, LEFT, RIGHT
"""

# ---------- A* ALGORITHM FOR 8-PUZZLE ----------
from heapq import heappush, heappop
import copy

GOAL_8PUZZLE = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]
]

def flatten(state):
    """Convert 2D state to 1D list"""
    return [num for row in state for num in row]

def is_solvable_8puzzle(state):
    """Check if puzzle is solvable by counting inversions"""
    flat = [num for num in flatten(state) if num != 0]
    inversions = 0
    for i in range(len(flat)):
        for j in range(i + 1, len(flat)):
            if flat[i] > flat[j]:
                inversions += 1
    return inversions % 2 == 0

def manhattan_distance(state):
    """Heuristic: sum of distances from current to goal position"""
    distance = 0
    for i in range(3):
        for j in range(3):
            tile = state[i][j]
            if tile != 0:
                goal_x, goal_y = divmod(tile - 1, 3)
                distance += abs(i - goal_x) + abs(j - goal_y)
    return distance

def misplaced_tiles(state):
    """Alternative heuristic: count misplaced tiles"""
    count = 0
    for i in range(3):
        for j in range(3):
            if state[i][j] != 0 and state[i][j] != GOAL_8PUZZLE[i][j]:
                count += 1
    return count

def get_blank_position(state):
    """Find blank (0) position"""
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j
    return -1, -1

def get_successors_8puzzle(state):
    """Generate all valid successor states"""
    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # UP, DOWN, LEFT, RIGHT
    blank_i, blank_j = get_blank_position(state)
    successors = []
    
    for di, dj in moves:
        ni, nj = blank_i + di, blank_j + dj
        if 0 <= ni < 3 and 0 <= nj < 3:
            new_state = copy.deepcopy(state)
            new_state[blank_i][blank_j], new_state[ni][nj] = new_state[ni][nj], new_state[blank_i][blank_j]
            successors.append(new_state)
    
    return successors

def state_to_tuple(state):
    """Convert state to hashable tuple"""
    return tuple(tuple(row) for row in state)

def a_star_8puzzle(start, goal=GOAL_8PUZZLE):
    """A* search for 8-puzzle"""
    pq = []
    heappush(pq, (manhattan_distance(start), 0, start, []))
    visited = set()
    
    while pq:
        f, g, state, path = heappop(pq)
        state_tuple = state_to_tuple(state)
        
        if state == goal:
            return path, len(visited)
        
        if state_tuple in visited:
            continue
        visited.add(state_tuple)
        
        for succ in get_successors_8puzzle(state):
            new_path = path + [succ]
            g_new = g + 1
            h = manhattan_distance(succ)
            f_new = g_new + h
            heappush(pq, (f_new, g_new, succ, new_path))
    
    return None, len(visited)

# ---------- DFS BRANCH & BOUND FOR 8-PUZZLE ----------
def dfs_branch_bound_8puzzle(start, goal=GOAL_8PUZZLE):
    """DFS Branch and Bound with pruning"""
    if not is_solvable_8puzzle(start):
        return None
    
    bound = float('inf')
    best_path = None
    stack = []
    visited = {}
    
    stack.append((start, [], 0))
    
    while stack:
        state, path, cost = stack.pop()
        state_t = state_to_tuple(state)
        heuristic = manhattan_distance(state)
        total_cost = cost + heuristic
        
        # Prune if exceeds bound
        if total_cost >= bound:
            continue
        
        # Skip if visited with lower cost
        if (state_t in visited) and (visited[state_t] <= cost):
            continue
        visited[state_t] = cost
        
        # Goal test
        if state == goal:
            bound = cost
            best_path = path + [state]
            continue
        
        # Expand successors
        for succ in get_successors_8puzzle(state):
            stack.append((succ, path + [state], cost + 1))
    
    return best_path

# ---------- BFS FOR 8-PUZZLE ----------
from collections import deque

def bfs_8puzzle(start, goal=GOAL_8PUZZLE):
    """Breadth-First Search"""
    queue = deque([(start, [])])
    visited = set()
    visited.add(state_to_tuple(start))
    
    while queue:
        state, path = queue.popleft()
        
        if state == goal:
            return path + [state]
        
        for succ in get_successors_8puzzle(state):
            succ_tuple = state_to_tuple(succ)
            if succ_tuple not in visited:
                visited.add(succ_tuple)
                queue.append((succ, path + [state]))
    
    return None

# ---------- USAGE EXAMPLE ----------
def solve_8puzzle_example():
    start_state = [
        [1, 2, 3],
        [4, 6, 0],
        [7, 5, 8]
    ]
    
    print("Initial State:")
    for row in start_state:
        print(row)
    
    if not is_solvable_8puzzle(start_state):
        print("Puzzle is NOT solvable!")
        return
    
    # A* Search
    solution, nodes = a_star_8puzzle(start_state)
    if solution:
        print(f"\nA* Solution found in {len(solution)} moves")
        print(f"Nodes explored: {nodes}")
    
    # DFS Branch & Bound
    solution_dfs = dfs_branch_bound_8puzzle(start_state)
    if solution_dfs:
        print(f"\nDFS B&B Solution found in {len(solution_dfs)-1} moves")


# ============================================================================
# 2. HAMILTONIAN CYCLE PROBLEM
# ============================================================================

"""
PROBLEM: Find a cycle that visits every vertex exactly once and returns to start.
INPUT: Graph represented as adjacency list with weights
OUTPUT: Hamiltonian cycle if exists, else None
"""

# ---------- BRANCH & BOUND FOR TSP/HAMILTONIAN ----------
import math

def tsp_branch_bound(graph, start):
    """TSP using Branch and Bound (finds minimum cost Hamiltonian cycle)"""
    n = len(graph)
    best = {"cost": math.inf, "path": []}
    
    # Precompute minimum edge weight from each node
    min_edge = [min(w for _, w in graph[v]) for v in range(n)]
    
    def dfs(path, visited, curr_cost):
        u = path[-1]
        
        # Lower bound estimate
        est = curr_cost + sum(min_edge[v] for v in range(n) if v not in visited)
        if est >= best["cost"]:
            return  # Prune
        
        # All vertices visited
        if len(path) == n:
            for nb, w in graph[u]:
                if nb == start:
                    total = curr_cost + w
                    if total < best["cost"]:
                        best["cost"] = total
                        best["path"] = path + [start]
            return
        
        # Explore neighbors
        for nb, w in graph[u]:
            if nb not in visited:
                dfs(path + [nb], visited | {nb}, curr_cost + w)
    
    dfs([start], {start}, 0)
    return (best["path"], best["cost"]) if best["cost"] < math.inf else (None, math.inf)

# ---------- A* FOR HAMILTONIAN CYCLE ----------
import heapq

def prims_mst(graph, nodes):
    """Prim's MST for heuristic calculation"""
    if not nodes:
        return 0
    
    start = next(iter(nodes))
    visited = {start}
    min_edges = [(w, start, nb) for nb, w in graph[start] if nb in nodes]
    heapq.heapify(min_edges)
    cost = 0
    
    while min_edges and len(visited) < len(nodes):
        w, u, v = heapq.heappop(min_edges)
        if v in visited:
            continue
        visited.add(v)
        cost += w
        for nb, wt in graph[v]:
            if nb in nodes and nb not in visited:
                heapq.heappush(min_edges, (wt, v, nb))
    
    return cost if len(visited) == len(nodes) else math.inf

def tsp_astar(graph, start_node):
    """A* for TSP with MST heuristic"""
    all_nodes = list(graph.keys())
    node_index = {v: i for i, v in enumerate(all_nodes)}
    n = len(all_nodes)
    
    def mask(v):
        return 1 << node_index[v]
    
    all_mask = (1 << n) - 1
    start_mask = mask(start_node)
    
    frontier = [(0, 0, start_node, start_mask, [start_node])]
    best_cost = {}
    
    while frontier:
        f, g, u, state, path = heapq.heappop(frontier)
        
        # All nodes visited
        if state == all_mask:
            for nb, w in graph[u]:
                if nb == start_node:
                    return path + [start_node], g + w
            continue
        
        # Duplicate check
        if (u, state) in best_cost and best_cost[(u, state)] <= g:
            continue
        best_cost[(u, state)] = g
        
        # Expand neighbors
        for nb, w in graph[u]:
            if state & mask(nb):
                continue
            new_state = state | mask(nb)
            new_g = g + w
            remaining = {v for v in all_nodes if not (new_state & mask(v))}
            heuristic = prims_mst(graph, remaining | {start_node, nb})
            heapq.heappush(frontier, (new_g + heuristic, new_g, nb, new_state, path + [nb]))
    
    return None, math.inf

# ---------- USAGE EXAMPLE ----------
def solve_hamiltonian_example():
    # Graph as adjacency list: {node: [(neighbor, weight), ...]}
    graph_dict = {
        'A': [('B', 2), ('C', 9), ('D', 10)],
        'B': [('A', 2), ('C', 6), ('D', 4)],
        'C': [('A', 9), ('B', 6), ('D', 3)],
        'D': [('A', 10), ('B', 4), ('C', 3)]
    }
    
    cycle, cost = tsp_astar(graph_dict, 'A')
    if cycle:
        print(f"Hamiltonian Cycle: {cycle}")
        print(f"Total Cost: {cost}")
    else:
        print("No Hamiltonian cycle found")
    
    # Integer graph format
    graph_int = {
        0: [(1, 10), (2, 15), (3, 20)],
        1: [(0, 10), (2, 35), (3, 25)],
        2: [(0, 15), (1, 35), (3, 30)],
        3: [(0, 20), (1, 25), (2, 30)]
    }
    
    tour, cost = tsp_branch_bound(graph_int, 0)
    if tour:
        print(f"Optimal Tour: {tour}")
        print(f"Minimum Cost: {cost}")


# ============================================================================
# 3. N-QUEENS PROBLEM
# ============================================================================

"""
PROBLEM: Place N queens on NxN chessboard so no two queens attack each other.
REPRESENTATION: List where index=column, value=row of queen
APPROACHES: Local Search (Min-Conflicts), Simulated Annealing, Backtracking
"""

# ---------- LOCAL SEARCH (MIN-CONFLICTS) ----------
import random

N = 8  # Board size

def count_conflicts(board):
    """Count number of attacking pairs"""
    conflicts = 0
    for i in range(len(board)):
        for j in range(i + 1, len(board)):
            # Same row or diagonal
            if board[i] == board[j] or abs(board[i] - board[j]) == abs(i - j):
                conflicts += 1
    return conflicts

def min_conflict_step(board):
    """Move one queen to minimize conflicts"""
    col = random.randint(0, len(board) - 1)
    best_row = board[col]
    best_conflict = count_conflicts(board)
    
    # Try all rows in selected column
    for row in range(len(board)):
        if row == board[col]:
            continue
        new_board = board[:]
        new_board[col] = row
        current_conflict = count_conflicts(new_board)
        if current_conflict < best_conflict:
            best_conflict = current_conflict
            best_row = row
    
    board[col] = best_row
    return board, best_conflict

def solve_nqueens_local_search(n=8, max_steps=500):
    """Solve N-Queens with random restart"""
    attempts = 0
    while True:
        attempts += 1
        board = [random.randint(0, n - 1) for _ in range(n)]
        conflicts = count_conflicts(board)
        
        steps = 0
        while steps < max_steps:
            if conflicts == 0:
                return board, attempts, steps
            
            board, new_conflicts = min_conflict_step(board)
            
            if new_conflicts == conflicts:
                break  # Stuck at local minimum
            
            conflicts = new_conflicts
            steps += 1

# ---------- SIMULATED ANNEALING ----------
def cost_nqueens(board):
    """Cost function = number of conflicts"""
    return count_conflicts(board)

def get_neighbor(board):
    """Generate neighbor by moving one queen or swapping"""
    n = len(board)
    if random.random() < 0.2:  # 20% chance to swap
        i, j = random.sample(range(n), 2)
        new_board = board[:]
        new_board[i], new_board[j] = new_board[j], new_board[i]
        return new_board
    
    # Move one queen
    i = random.randrange(n)
    r = random.randrange(n)
    while r == board[i]:
        r = random.randrange(n)
    new_board = board[:]
    new_board[i] = r
    return new_board

def simulated_annealing_nqueens(n=8, T_init=10.0, T_min=1e-4, alpha=0.995, max_iter=200000):
    """Simulated Annealing for N-Queens"""
    # Random initial state
    board = [random.randint(0, n - 1) for _ in range(n)]
    cost = cost_nqueens(board)
    best_board = board[:]
    best_cost = cost
    
    T = T_init
    iterations = 0
    
    while T > T_min and cost > 0 and iterations < max_iter:
        iterations += 1
        
        # Generate neighbor
        new_board = get_neighbor(board)
        new_cost = cost_nqueens(new_board)
        
        # Accept if better or with probability
        if new_cost < cost or random.random() < math.exp((cost - new_cost) / T):
            board, cost = new_board, new_cost
            if cost < best_cost:
                best_board, best_cost = board[:], cost
        
        T *= alpha
    
    return best_board, best_cost, iterations

# ---------- BACKTRACKING (COMPLETE SEARCH) ----------
def is_safe(board, row, col):
    """Check if placing queen at (row, col) is safe"""
    # Check column
    for i in range(row):
        if board[i] == col:
            return False
    
    # Check diagonals
    for i in range(row):
        if abs(board[i] - col) == abs(i - row):
            return False
    
    return True

def solve_nqueens_backtrack(n=8):
    """Backtracking solution"""
    board = [-1] * n
    
    def backtrack(row):
        if row == n:
            return True
        
        for col in range(n):
            if is_safe(board, row, col):
                board[row] = col
                if backtrack(row + 1):
                    return True
                board[row] = -1
        
        return False
    
    if backtrack(0):
        return board
    return None

# ---------- UTILITY FUNCTIONS ----------
def print_board_nqueens(board):
    """Print chessboard"""
    n = len(board)
    for row in range(n):
        line = []
        for col in range(n):
            line.append('Q' if board[col] == row else '.')
        print(' '.join(line))

def matrix_to_list_nqueens(matrix):
    """Convert 2D matrix to 1D representation"""
    n = len(matrix)
    board = [-1] * n
    for r in range(n):
        for c in range(n):
            if matrix[r][c] == 1:
                board[c] = r
    return board

def list_to_matrix_nqueens(board):
    """Convert 1D representation to 2D matrix"""
    n = len(board)
    matrix = [[0 for _ in range(n)] for _ in range(n)]
    for c, r in enumerate(board):
        matrix[r][c] = 1
    return matrix

# ---------- USAGE EXAMPLE ----------
def solve_nqueens_example():
    # Simulated Annealing
    solution, cost, iters = simulated_annealing_nqueens(8)
    print(f"SA Solution (cost={cost}, iterations={iters}):")
    print_board_nqueens(solution)
    
    # Local Search
    solution, attempts, steps = solve_nqueens_local_search(8)
    print(f"\nLocal Search Solution (attempts={attempts}, steps={steps}):")
    print_board_nqueens(solution)
    
    # Backtracking
    solution = solve_nqueens_backtrack(8)
    if solution:
        print("\nBacktracking Solution:")
        print_board_nqueens(solution)


# ============================================================================
# 4. NIM GAME (MINIMAX & ALPHA-BETA PRUNING)
# ============================================================================

"""
PROBLEM: Two-player game with heaps of stones. Players take turns removing 
         stones from one heap. Last player to move wins.
STATE: Tuple of integers (heap1_size, heap2_size, ...)
ALGORITHMS: Minimax, Alpha-Beta Pruning
"""

# ---------- GAME STATE FUNCTIONS ----------
def is_terminal_nim(state):
    """Check if game is over (all heaps empty)"""
    return all(h == 0 for h in state)

def get_moves_nim(state):
    """Generate all possible moves"""
    moves = []
    for i, heap in enumerate(state):
        if heap > 0:
            for remove in range(1, heap + 1):
                new_state = list(state)
                new_state[i] -= remove
                moves.append(tuple(new_state))
    return moves

def evaluate_nim(state, is_max_turn):
    """Utility function: +1 if MAX wins, -1 if MIN wins"""
    return -1 if is_max_turn else 1

# ---------- MINIMAX ALGORITHM ----------
stats_minimax = {"visited": 0}

def minimax_nim(state, is_max_turn=True):
    """Standard Minimax without pruning"""
    stats_minimax["visited"] += 1
    
    if is_terminal_nim(state):
        return evaluate_nim(state, is_max_turn)
    
    if is_max_turn:
        best_value = float('-inf')
        for move in get_moves_nim(state):
            value = minimax_nim(move, False)
            best_value = max(best_value, value)
        return best_value
    else:
        best_value = float('inf')
        for move in get_moves_nim(state):
            value = minimax_nim(move, True)
            best_value = min(best_value, value)
        return best_value

# ---------- ALPHA-BETA PRUNING ----------
stats_alphabeta = {"visited": 0, "cutoffs": 0}

def alphabeta_nim(state, is_max_turn, alpha, beta):
    """Minimax with Alpha-Beta Pruning"""
    stats_alphabeta["visited"] += 1
    
    if is_terminal_nim(state):
        return evaluate_nim(state, is_max_turn)
    
    if is_max_turn:
        best_value = float('-inf')
        for move in get_moves_nim(state):
            value = alphabeta_nim(move, False, alpha, beta)
            best_value = max(best_value, value)
            alpha = max(alpha, best_value)
            if alpha >= beta:
                stats_alphabeta["cutoffs"] += 1
                break  # Beta cutoff
        return best_value
    else:
        best_value = float('inf')
        for move in get_moves_nim(state):
            value = alphabeta_nim(move, True, alpha, beta)
            best_value = min(best_value, value)
            beta = min(beta, best_value)
            if alpha >= beta:
                stats_alphabeta["cutoffs"] += 1
                break  # Alpha cutoff
        return best_value

# ---------- FIND BEST MOVE ----------
def find_best_move_minimax(initial_state):
    """Find optimal move using Minimax"""
    best_value = float('-inf')
    best_move = None
    
    for move in get_moves_nim(initial_state):
        value = minimax_nim(move, False)
        if value > best_value:
            best_value = value
            best_move = move
    
    return best_move, int(best_value)

def find_best_move_alphabeta(initial_state):
    """Find optimal move using Alpha-Beta"""
    best_value = float('-inf')
    best_move = None
    alpha = float('-inf')
    beta = float('inf')
    
    for move in get_moves_nim(initial_state):
        value = alphabeta_nim(move, False, alpha, beta)
        if value > best_value:
            best_value = value
            best_move = move
        alpha = max(alpha, best_value)
    
    return best_move, int(best_value)

# ---------- USAGE EXAMPLE ----------
def solve_nim_example():
    initial_state = (3, 4, 5)
    
    # Reset stats
    stats_minimax["visited"] = 0
    stats_alphabeta["visited"] = 0
    stats_alphabeta["cutoffs"] = 0
    
    # Minimax
    move_mm, value_mm = find_best_move_minimax(initial_state)
    print(f"Initial State: {initial_state}")
    print(f"\nMinimax:")
    print(f"  Best Move: {initial_state} -> {move_mm}")
    print(f"  Value: {value_mm}")
    print(f"  Nodes Visited: {stats_minimax['visited']}")
    
    # Alpha-Beta
    stats_alphabeta["visited"] = 0
    stats_alphabeta["cutoffs"] = 0
    move_ab, value_ab = find_best_move_alphabeta(initial_state)
    print(f"\nAlpha-Beta:")
    print(f"  Best Move: {initial_state} -> {move_ab}")
    print(f"  Value: {value_ab}")
    print(f"  Nodes Visited: {stats_alphabeta['visited']}")
    print(f"  Cutoffs: {stats_alphabeta['cutoffs']}")
    print(f"\nNodes Saved: {stats_minimax['visited'] - stats_alphabeta['visited']}")


# ============================================================================
# 5. GRAPH SEARCH ALGORITHMS
# ============================================================================

"""
General graph search algorithms for various problems.
Graph representation: adjacency list {node: [(neighbor, cost), ...]}
"""

# ---------- BREADTH-FIRST SEARCH (BFS) ----------
from collections import deque

def bfs_graph(graph, start, goal):
    """BFS - finds shortest path (unweighted)"""
    queue = deque([(start, [start])])
    visited = {start}
    
    while queue:
        node, path = queue.popleft()
        
        if node == goal:
            return path
        
        for neighbor, _ in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    
    return None

# ---------- DEPTH-FIRST SEARCH (DFS) ----------
def dfs_graph(graph, start, goal):
    """DFS - may not find shortest path"""
    stack = [(start, [start])]
    visited = set()
    
    while stack:
        node, path = stack.pop()
        
        if node in visited:
            continue
        visited.add(node)
        
        if node == goal:
            return path
        
        for neighbor, _ in graph.get(node, []):
            if neighbor not in visited:
                stack.append((neighbor, path + [neighbor]))
    
    return None

# ---------- UNIFORM COST SEARCH (UCS) ----------
def ucs_graph(graph, start, goal):
    """UCS - Dijkstra's algorithm"""
    pq = [(0, start, [start])]
    visited = set()
    
    while pq:
        cost, node, path = heapq.heappop(pq)
        
        if node in visited:
            continue
        visited.add(node)
        
        if node == goal:
            return path, cost
        
        for neighbor, edge_cost in graph.get(node, []):
            if neighbor not in visited:
                heapq.heappush(pq, (cost + edge_cost, neighbor, path + [neighbor]))
    
    return None, float('inf')

# ---------- A* SEARCH ----------
def astar_graph(graph, start, goal, heuristic):
    """A* search with custom heuristic function"""
    pq = [(heuristic(start, goal), 0, start, [start])]
    visited = {}
    
    while pq:
        f, g, node, path = heapq.heappop(pq)
        
        if node in visited and visited[node] <= g:
            continue
        visited[node] = g
        
        if node == goal:
            return path, g
        
        for neighbor, cost in graph.get(node, []):
            new_g = g + cost
            h = heuristic(neighbor, goal)
            f_new = new_g + h
            heapq.heappush(pq, (f_new, new_g, neighbor, path + [neighbor]))
    
    return None, float('inf')

# ---------- BIDIRECTIONAL SEARCH ----------
def bidirectional_search(graph, start, goal):
    """Search from both start and goal"""
    if start == goal:
        return [start]
    
    forward_queue = deque([(start, [start])])
    backward_queue = deque([(goal, [goal])])
    forward_visited = {start: [start]}
    backward_visited = {goal: [goal]}
    
    while forward_queue and backward_queue:
        # Forward search
        node, path = forward_queue.popleft()
        for neighbor, _ in graph.get(node, []):
            if neighbor in backward_visited:
                return path + backward_visited[neighbor][::-1]
            if neighbor not in forward_visited:
                forward_visited[neighbor] = path + [neighbor]
                forward_queue.append((neighbor, path + [neighbor]))
        
        # Backward search
        node, path = backward_queue.popleft()
        for neighbor, _ in graph.get(node, []):
            if neighbor in forward_visited:
                return forward_visited[neighbor] + path[::-1]
            if neighbor not in backward_visited:
                backward_visited[neighbor] = path + [neighbor]
                backward_queue.append((neighbor, path + [neighbor]))
    
    return None


# ============================================================================
# 6. TRAVELING SALESMAN PROBLEM (TSP)
# ============================================================================

"""
Additional TSP approaches beyond Hamiltonian cycle
"""

# ---------- NEAREST NEIGHBOR HEURISTIC ----------
def tsp_nearest_neighbor(graph, start):
    """Greedy nearest neighbor heuristic"""
    unvisited = set(graph.keys())
    current = start
    tour = [current]
    total_cost = 0
    unvisited.remove(current)
    
    while unvisited:
        nearest = None
        nearest_cost = float('inf')
        
        for neighbor, cost in graph[current]:
            if neighbor in unvisited and cost < nearest_cost:
                nearest = neighbor
                nearest_cost = cost
        
        if nearest is None:
            return None, float('inf')
        
        tour.append(nearest)
        total_cost += nearest_cost
        current = nearest
        unvisited.remove(current)
    
    # Return to start
    for neighbor, cost in graph[current]:
        if neighbor == start:
            tour.append(start)
            total_cost += cost
            return tour, total_cost
    
    return None, float('inf')

# ---------- DYNAMIC PROGRAMMING TSP ----------
def tsp_dp(graph, start):
    """Exact DP solution for TSP (Held-Karp algorithm)"""
    nodes = list(graph.keys())
    n = len(nodes)
    node_to_idx = {node: i for i, node in enumerate(nodes)}
    
    # dp[mask][i] = min cost to visit all nodes in mask ending at i
    dp = {}
    parent = {}
    
    # Base case: starting at start
    start_idx = node_to_idx[start]
    dp[(1 << start_idx, start_idx)] = 0
    
    # Iterate through all subsets
    for mask in range(1, 1 << n):
        for i in range(n):
            if not (mask & (1 << i)):
                continue
            if (mask, i) not in dp:
                continue
            
            current_cost = dp[(mask, i)]
            current_node = nodes[i]
            
            # Try to extend to unvisited nodes
            for neighbor, cost in graph[current_node]:
                j = node_to_idx[neighbor]
                if mask & (1 << j):
                    continue
                
                new_mask = mask | (1 << j)
                new_cost = current_cost + cost
                
                if (new_mask, j) not in dp or new_cost < dp[(new_mask, j)]:
                    dp[(new_mask, j)] = new_cost
                    parent[(new_mask, j)] = i
    
    # Find best way to return to start
    full_mask = (1 << n) - 1
    best_cost = float('inf')
    best_last = -1
    
    for i in range(n):
        if i == start_idx:
            continue
        if (full_mask, i) not in dp:
            continue
        
        # Check if we can return to start
        current_node = nodes[i]
        for neighbor, cost in graph[current_node]:
            if neighbor == start:
                total = dp[(full_mask, i)] + cost
                if total < best_cost:
                    best_cost = total
                    best_last = i
    
    if best_last == -1:
        return None, float('inf')
    
    # Reconstruct path
    path = []
    mask = full_mask
    current = best_last
    
    while mask > 0:
        path.append(nodes[current])
        if (mask, current) not in parent:
            break
        prev = parent[(mask, current)]
        mask ^= (1 << current)
        current = prev
    
    path.reverse()
    path.append(start)
    
    return path, best_cost


# ============================================================================
# 7. UTILITY FUNCTIONS & COMMON HELPERS
# ============================================================================

# ---------- GRAPH CONSTRUCTION ----------
def create_graph_from_edges(edges):
    """Create adjacency list from edge list"""
    graph = {}
    for u, v, w in edges:
        if u not in graph:
            graph[u] = []
        if v not in graph:
            graph[v] = []
        graph[u].append((v, w))
        graph[v].append((u, w))  # For undirected
    return graph

def create_directed_graph(edges):
    """Create directed adjacency list"""
    graph = {}
    for u, v, w in edges:
        if u not in graph:
            graph[u] = []
        graph[u].append((v, w))
    return graph

def create_complete_graph(nodes, cost_matrix):
    """Create complete graph from cost matrix"""
    graph = {}
    n = len(nodes)
    for i in range(n):
        graph[nodes[i]] = []
        for j in range(n):
            if i != j:
                graph[nodes[i]].append((nodes[j], cost_matrix[i][j]))
    return graph

# ---------- GRID HELPERS ----------
def grid_to_graph(grid, blocked_val='#'):
    """Convert 2D grid to graph for pathfinding"""
    rows, cols = len(grid), len(grid[0])
    graph = {}
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == blocked_val:
                continue
            
            node = (r, c)
            graph[node] = []
            
            # 4-directional neighbors
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != blocked_val:
                    neighbor = (nr, nc)
                    cost = 1 if grid[nr][nc] == '.' else int(grid[nr][nc])
                    graph[node].append((neighbor, cost))
    
    return graph

def euclidean_distance(p1, p2):
    """Euclidean distance heuristic for grid"""
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def manhattan_distance_grid(p1, p2):
    """Manhattan distance for grid"""
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

# ---------- PRINTING HELPERS ----------
def print_path(path):
    """Pretty print path"""
    if path:
        print(" -> ".join(map(str, path)))
    else:
        print("No path found")

def print_solution_8puzzle(solution):
    """Print 8-puzzle solution steps"""
    if not solution:
        print("No solution found")
        return
    
    for idx, state in enumerate(solution):
        print(f"Step {idx}:")
        for row in state:
            print(row)
        print("---")
    print(f"Total moves: {len(solution) - 1}")

def visualize_path_grid(grid, path, start, goal):
    """Visualize path on grid"""
    result = [row[:] for row in grid]
    for r, c in path:
        if (r, c) != start and (r, c) != goal:
            result[r][c] = '*'
    result[start[0]][start[1]] = 'S'
    result[goal[0]][goal[1]] = 'G'
    
    for row in result:
        print(' '.join(str(cell) for cell in row))

# ---------- PERFORMANCE TRACKING ----------
def track_performance(func):
    """Decorator to track time and memory"""
    import time
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f} seconds")
        return result
    return wrapper


# ============================================================================
# 8. COMPLETE WORKING EXAMPLES
# ============================================================================

# ---------- EXAMPLE 1: 8-PUZZLE ----------
def example_8puzzle_full():
    """Complete 8-puzzle example"""
    print("="*60)
    print("8-PUZZLE PROBLEM")
    print("="*60)
    
    start = [
        [7, 2, 3],
        [5, 0, 6],
        [4, 1, 8]
    ]
    
    print("Initial State:")
    for row in start:
        print(row)
    
    if not is_solvable_8puzzle(start):
        print("\nThis puzzle is NOT solvable!")
        return
    
    print("\nSolving with A*...")
    solution, nodes = a_star_8puzzle(start)
    
    if solution:
        print(f"\nSolution found!")
        print(f"Number of moves: {len(solution)}")
        print(f"Nodes explored: {nodes}")
        print("\nFirst few steps:")
        for i, state in enumerate(solution[:5]):
            print(f"Step {i}:")
            for row in state:
                print(row)
            print()
    
    print("\nSolving with DFS Branch & Bound...")
    solution_dfs = dfs_branch_bound_8puzzle(start)
    if solution_dfs:
        print(f"DFS B&B found solution in {len(solution_dfs)-1} moves")


# ---------- EXAMPLE 2: N-QUEENS ----------
def example_nqueens_full():
    """Complete N-Queens example"""
    print("="*60)
    print("N-QUEENS PROBLEM")
    print("="*60)
    
    n = 8
    
    # Simulated Annealing
    print(f"\nSolving {n}-Queens with Simulated Annealing...")
    solution, cost, iters = simulated_annealing_nqueens(n)
    print(f"Result: cost={cost}, iterations={iters}")
    if cost == 0:
        print("Solution found!")
        print_board_nqueens(solution)
    
    # Local Search
    print(f"\nSolving {n}-Queens with Local Search...")
    solution, attempts, steps = solve_nqueens_local_search(n)
    print(f"Result: attempts={attempts}, final_steps={steps}")
    print("Solution:")
    print_board_nqueens(solution)
    
    # Backtracking
    print(f"\nSolving {n}-Queens with Backtracking...")
    solution = solve_nqueens_backtrack(n)
    if solution:
        print("Solution found!")
        print_board_nqueens(solution)


# ---------- EXAMPLE 3: NIM GAME ----------
def example_nim_full():
    """Complete Nim game example"""
    print("="*60)
    print("NIM GAME - MINIMAX vs ALPHA-BETA")
    print("="*60)
    
    initial_state = (3, 4, 5)
    print(f"Initial State: {initial_state}")
    
    # Minimax
    print("\nRunning Minimax...")
    stats_minimax["visited"] = 0
    move_mm, value_mm = find_best_move_minimax(initial_state)
    print(f"Best Move: {initial_state} -> {move_mm}")
    print(f"Value: {value_mm}")
    print(f"Nodes Visited: {stats_minimax['visited']}")
    
    # Alpha-Beta
    print("\nRunning Alpha-Beta Pruning...")
    stats_alphabeta["visited"] = 0
    stats_alphabeta["cutoffs"] = 0
    move_ab, value_ab = find_best_move_alphabeta(initial_state)
    print(f"Best Move: {initial_state} -> {move_ab}")
    print(f"Value: {value_ab}")
    print(f"Nodes Visited: {stats_alphabeta['visited']}")
    print(f"Cutoffs: {stats_alphabeta['cutoffs']}")
    
    reduction = stats_minimax['visited'] - stats_alphabeta['visited']
    print(f"\nEfficiency Gain: {reduction} nodes saved ({reduction/stats_minimax['visited']*100:.1f}% reduction)")


# ---------- EXAMPLE 4: TSP/HAMILTONIAN ----------
def example_tsp_full():
    """Complete TSP example"""
    print("="*60)
    print("TRAVELING SALESMAN PROBLEM")
    print("="*60)
    
    graph = {
        'A': [('B', 2), ('C', 9), ('D', 10)],
        'B': [('A', 2), ('C', 6), ('D', 4)],
        'C': [('A', 9), ('B', 6), ('D', 3)],
        'D': [('A', 10), ('B', 4), ('C', 3)]
    }
    
    print("Graph:")
    for node, edges in graph.items():
        print(f"  {node}: {edges}")
    
    # A* approach
    print("\nSolving with A* (MST heuristic)...")
    tour, cost = tsp_astar(graph, 'A')
    if tour:
        print(f"Tour: {tour}")
        print(f"Cost: {cost}")
    
    # Branch & Bound
    print("\nSolving with Branch & Bound...")
    graph_int = {
        0: [(1, 2), (2, 9), (3, 10)],
        1: [(0, 2), (2, 6), (3, 4)],
        2: [(0, 9), (1, 6), (3, 3)],
        3: [(0, 10), (1, 4), (2, 3)]
    }
    tour, cost = tsp_branch_bound(graph_int, 0)
    if tour:
        print(f"Tour: {tour}")
        print(f"Cost: {cost}")


# ---------- EXAMPLE 5: GRAPH SEARCH ----------
def example_graph_search_full():
    """Complete graph search example"""
    print("="*60)
    print("GRAPH SEARCH ALGORITHMS")
    print("="*60)
    
    # Create sample graph
    edges = [
        ('A', 'B', 1), ('A', 'C', 4),
        ('B', 'C', 2), ('B', 'D', 5),
        ('C', 'D', 1), ('D', 'E', 3)
    ]
    graph = create_graph_from_edges(edges)
    
    start, goal = 'A', 'E'
    
    # BFS
    print(f"\nBFS from {start} to {goal}:")
    path = bfs_graph(graph, start, goal)
    print_path(path)
    
    # DFS
    print(f"\nDFS from {start} to {goal}:")
    path = dfs_graph(graph, start, goal)
    print_path(path)
    
    # UCS
    print(f"\nUCS from {start} to {goal}:")
    path, cost = ucs_graph(graph, start, goal)
    if path:
        print_path(path)
        print(f"Cost: {cost}")
    
    # A*
    def simple_heuristic(node, goal):
        # Simple heuristic for demo
        return 0
    
    print(f"\nA* from {start} to {goal}:")
    path, cost = astar_graph(graph, start, goal, simple_heuristic)
    if path:
        print_path(path)
        print(f"Cost: {cost}")


# ============================================================================
# 9. QUICK REFERENCE TEMPLATES
# ============================================================================

"""
TEMPLATE 1: Basic Graph Search
-------------------------------
from heapq import heappush, heappop

def search(graph, start, goal):
    pq = [(0, start, [start])]
    visited = set()
    
    while pq:
        cost, node, path = heappop(pq)
        
        if node in visited:
            continue
        visited.add(node)
        
        if node == goal:
            return path
        
        for neighbor, edge_cost in graph[node]:
            if neighbor not in visited:
                heappush(pq, (cost + edge_cost, neighbor, path + [neighbor]))
    
    return None


TEMPLATE 2: Backtracking
-------------------------
def backtrack(state, path):
    if is_goal(state):
        return path
    
    for next_state in get_successors(state):
        if is_valid(next_state):
            result = backtrack(next_state, path + [next_state])
            if result:
                return result
    
    return None


TEMPLATE 3: Branch & Bound
---------------------------
def branch_bound(start):
    best = {"cost": float('inf'), "solution": None}
    stack = [(start, [], 0)]
    
    while stack:
        state, path, cost = stack.pop()
        
        # Prune if exceeds bound
        if cost + heuristic(state) >= best["cost"]:
            continue
        
        if is_goal(state):
            if cost < best["cost"]:
                best = {"cost": cost, "solution": path}
            continue
        
        for next_state in get_successors(state):
            stack.append((next_state, path + [next_state], cost + step_cost))
    
    return best


TEMPLATE 4: Simulated Annealing
--------------------------------
import random, math

def simulated_annealing(initial_state):
    state = initial_state
    cost = evaluate(state)
    T = 10.0
    
    while T > 0.0001:
        neighbor = get_neighbor(state)
        neighbor_cost = evaluate(neighbor)
        
        if neighbor_cost < cost or random.random() < math.exp((cost - neighbor_cost) / T):
            state = neighbor
            cost = neighbor_cost
        
        T *= 0.995
    
    return state


TEMPLATE 5: Minimax with Alpha-Beta
------------------------------------
def minimax(state, is_max, alpha, beta):
    if is_terminal(state):
        return evaluate(state)
    
    if is_max:
        value = float('-inf')
        for move in get_moves(state):
            value = max(value, minimax(move, False, alpha, beta))
            alpha = max(alpha, value)
            if alpha >= beta:
                break  # Beta cutoff
        return value
    else:
        value = float('inf')
        for move in get_moves(state):
            value = min(value, minimax(move, True, alpha, beta))
            beta = min(beta, value)
            if alpha >= beta:
                break  # Alpha cutoff
        return value
"""


# ============================================================================
# 10. COMMON IMPORTS & SETUP
# ============================================================================

"""
ESSENTIAL IMPORTS:
------------------
from heapq import heappush, heappop, heapify
from collections import deque, defaultdict
import copy
import random
import math
import time

DATA STRUCTURES:
----------------
# Priority Queue
pq = []
heappush(pq, (priority, item))
priority, item = heappop(pq)

# Queue (BFS)
queue = deque()
queue.append(item)
item = queue.popleft()

# Stack (DFS)
stack = []
stack.append(item)
item = stack.pop()

# Set (visited tracking)
visited = set()
visited.add(item)
if item in visited: ...

# Dictionary (memoization)
memo = {}
memo[key] = value
"""


# ============================================================================
# MAIN EXECUTION - RUN ALL EXAMPLES
# ============================================================================

if __name__ == "__main__":
    print("\n" + "="*70)
    print(" AI LAB EXAM - COMPREHENSIVE DEMONSTRATION")
    print("="*70)
    
    # Uncomment to run specific examples:
    
    # example_8puzzle_full()
    # print("\n" * 3)
    
    # example_nqueens_full()
    # print("\n" * 3)
    
    # example_nim_full()
    # print("\n" * 3)
    
    # example_tsp_full()
    # print("\n" * 3)
    
    # example_graph_search_full()
    
    print("\n" + "="*70)
    print(" ALL ALGORITHMS READY - GOOD LUCK ON YOUR EXAM!")
    print("="*70)


# ============================================================================
# EXAM TIPS & TRICKS
# ============================================================================

"""
QUICK DEBUGGING TIPS:
---------------------
1. Print state at each step: print(f"Current: {state}")
2. Track visited nodes: print(f"Visited: {len(visited)}")
3. Verify goal condition: print(f"Is goal? {state == goal}")
4. Check heuristic values: print(f"h(state) = {heuristic(state)}")

COMMON MISTAKES TO AVOID:
--------------------------
1. Forgetting to check if state already visited
2. Not converting state to tuple for hashing
3. Wrong priority in heap (should be f = g + h for A*)
4. Not handling terminal states in minimax
5. Forgetting to update alpha/beta in pruning
6. Off-by-one errors in grid coordinates
7. Not deep copying states when modifying

PERFORMANCE OPTIMIZATION:
-------------------------
1. Use tuple() for state representation in visited set
2. Implement proper pruning in branch & bound
3. Choose good heuristics (admissible for A*)
4. Use alpha-beta instead of plain minimax
5. Add memoization for repeated states

TIME MANAGEMENT:
----------------
1. Read problem carefully (2 min)
2. Identify algorithm type (1 min)
3. Write skeleton code (3 min)
4. Implement core logic (10 min)
5. Test with examples (3 min)
6. Debug if needed (5 min)

ALGORITHM SELECTION GUIDE:
--------------------------
- Shortest path, weighted graph → A* or UCS
- Shortest path, unweighted → BFS
- Any path quickly → DFS
- Optimal solution required → Branch & Bound or DP
- Large state space → Local Search or Simulated Annealing
- Two-player game → Minimax with Alpha-Beta
- Constraint satisfaction → Backtracking
- Puzzle solving → A* with good heuristic
"""